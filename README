// Copyright 2019 NICHITA RADU 4.05.2019 TEMA 2 STRUCTURI DE DATE


README

included:
All source files (genericskip.cpp LinkedList.cpp main.cpp Driver.h Location.h 
Graph.h Hashtable.h)
this README
Makefile

Homework #2

Data structures:

1->Generic LinkedList & SkipList - taken from Homework #1, the same 
implementation
2->Generic HashTable with basic functions(insert,update,delete,search)
3->Generic GraphHashtable that map generic datatype to int using a Hashtable 
and basic functions(addEdge, remove Edge, determine distance between 2 nodes,
determine distance between 2 nodes, via a midpoint) 


Task1-> checking if 2 stations were connected was made by checking if there 
		was a path between the nodes resulted via Hashtable
Task2-> the same idea, but this time I used the distance between 2 nodes
Task3-> adding and removing roads between stations was easily handled by 
        addEdge and removeEdge functions and the map provided by Hashtable
Task4-> I choosed to keep drivers in a vector,as it was easier to handle the
		updates for distance,rating and rides. A separate class of Location
		storing the Drivers for a location was a good option in order to 
		determine which driver is the most suitable for every passenger,
		according to rating and name. Determing the closest driver is using a
		modified BFS algorithm, to find the most closest driver,starting from 
		source and stoping after finding the first driver with a higher
		distance than one available for that ride.After that, is was possible
		to check if the destionation was available and do some computations to
		update the statistics for that drivers.
		All sorts were made using skiplist in O(n * log n) complexity, instead
		of using BubbleSort or QuickSort.
Optimization:
		1.Almost every "r" command produces a modification in all leaderboards,
		so I decided to track when these modifications happen by having the ok 
		variable. If there is no "r" command that causes problems, there is no
		need for sorting, so we print the number of elements required.
		2.When a sorting is neccesary, we modify the order od drivers in vector,
		because sorting it in the future will require little computation, as it
		is "almost sorted".
		3.BFS to find the closest driver, instead of checking every driver.
Task5-> For every station, I checked if there enough fuel to get there,and if
		so, the destination was put in a vector, always checking for 
		duplicates. After all destinations were computed, a Bubble Sort was
		good enough to sort destinations after distance and time.

Problems faced:
	1.Time optimization - when I started making time optimization, the timeout
						  for test10 task4 was about 1500ms and reduced it to
						  almost 120ms
	2.Tricky condition- It was not very clear what was meant by the sentence
						"If the destionation is not available, you should try
						to reach one of its neighbors".
	3.VMChecker- There is a little bit more time needed on vmchecker than it 
			     was on my laptop, and it required further optimizations

Feedback:
	For me it was a very challenging hw, although I didn't managed to get all
	points on VMChecker. It was very fun trying to find optimizations in code.
	I liked the problem' idea, because it is better to deal with real-life 
	situations.
